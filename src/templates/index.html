<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Perdisco Flashcards Tool</title>
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script>
    window.MathJax = {
      tex: { 
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$', '$$'], ['\\[', '\\]']]
      }
    };
  </script>
  <script id="MathJax-script" async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
  </script>
  <style>
    /* Disable double-tap zoom on all elements */
    * {
      touch-action: manipulation;
    }
    
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      font-family: sans-serif;
      text-align: center;
      background: #eef;
      font-size: 18px;
    }
    
    /* Styles for incorrect attempts history */
    #incorrect-attempts-history {
      margin: 20px auto;
      width: 60%;
      max-width: 600px;
      text-align: left;
    }
    
    #incorrect-attempts-history h3 {
      color: #555;
      font-size: 18px;
      margin-bottom: 10px;
    }
    
    #incorrect-attempts-list {
      list-style-type: none;
      padding: 0;
      margin: 0;
    }
    
    .incorrect-attempt-item {
      padding: 10px;
      margin-bottom: 8px;
      border-left: 3px solid #dc3545;
      background-color: #f8f9fa;
      border-radius: 4px;
      position: relative; /* For positioning the delete button */
    }
    
    .incorrect-attempt-date {
      font-size: 14px;
      color: #6c757d;
      margin-bottom: 5px;
      padding-right: 25px; /* Make room for delete button */
    }
    
    .incorrect-attempt-reason {
      font-size: 16px;
    }
    
    .no-attempts-message {
      color: #6c757d;
      font-style: italic;
    }
    
    /* Delete button styling */
    .delete-attempt-button {
      position: absolute;
      top: 8px;
      right: 8px;
      width: 24px;
      height: 24px;
      border-radius: 50%;
      background-color: #ffffff;
      color: white;
      border: none;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      opacity: 0.7;
      transition: opacity 0.2s;
    }
    
    .delete-attempt-button:hover {
      opacity: 1;
    }
    
    .delete-attempt-button .material-icons {
      font-size: 16px;
      line-height: 1;
      color: black;
    }
    
    /* Update the mobile control bar to position at bottom left */
    .mobile-control-bar {
      position: fixed;
      top: 80px; /* Position further up to make room for both buttons */
      right: 20px;
      transform: none;
      z-index: 100;
      display: none; /* Hidden by default */
      flex-direction: column;
      gap: 10px;
    }

    /* Make the focus mode button match the styling of the control buttons */
    #focus-mode-toggle {
      position: fixed;
      top: 20px;
      left: 20px;
      z-index: 100;
      background-color: #4682B4;
      color: white;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      border: none;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
      cursor: pointer;
    }

    /* Menu button styling */
    #mobile-menu-toggle {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 100;
      background-color: #fd1414;
      color: white;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      border: none;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
      cursor: pointer;
    }

    /* Hide mobile menu toggle on desktop */
    @media (min-width: 769px) {
      #mobile-menu-toggle {
        display: none;
      }
    }
    
    .mobile-control-button {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      border: none;
      background-color: #6c757d;
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
      cursor: pointer;
    }
    
    #mobile-edit {
      background-color: #6610f2;
    }
    
    #mobile-filter {
      background-color: #fd7e14;
    }
    
    #mobile-history {
      background-color: #20c997;
    }
    
    #mobile-clear-attempts {
      background-color: #dc3545;
    }
    
    /* Update the mobile actions bar to float at bottom of screen */
    .mobile-actions {
      position: fixed;
      bottom: 20px;
      left: 0;
      right: 0;
      display: flex;
      justify-content: center;
      margin: 0 auto;
      gap: 20px;
      padding: 10px;
      background-color: rgba(240, 240, 245, 0.8); /* Semi-transparent background */
      backdrop-filter: blur(5px); /* Blur background for better readability */
      border-radius: 30px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
      width: fit-content;
      z-index: 90;
    }

    /* Add padding to bottom of body to prevent content being hidden behind the action bar */
    @media (max-width: 768px) {
      body {
        padding-bottom: 100px;
        padding-top: 50px; /* Add top padding to make room for buttons */
      }
      
      #performance-stats {
        margin-top: 20px; /* Additional margin for the first content element */
      }
    }
    
    .mobile-button {
      width: 60px;
      height: 60px;
      border-radius: 50%;
      border: none;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
      cursor: pointer;
      transition: transform 0.2s, background-color 0.2s;
    }
    
    .mobile-button:active {
      transform: scale(0.95);
    }
    
    .mobile-button .material-icons {
      font-size: 30px;
    }
    
    .correct-button {
      background-color: #28a745;
      color: white;
    }
    
    .incorrect-button {
      background-color: #dc3545;
      color: white;
    }
    
    .nav-button {
      background-color: #6c757d;
      color: white;
    }
    
    /* Hide mobile controls on desktop, show on mobile */
    @media (min-width: 769px) {
      .mobile-actions {
        display: none;
      }
      
      #focus-mode-toggle {
        display: none;
      }
      
      .mobile-control-bar {
        display: none;
      }
    }
    
    .flashcard {
      width: 90% !important;
      margin: 10px auto !important;
      padding: 15px !important;
    }
    
    #filter-controls {
      max-width: 90% !important;
    }
    
    #incorrect-attempts-history {
      width: 90% !important;
    }
    
    .filter-label {
      display: none; /* Hide labels on mobile to save space */
    }
    
    .filter-input {
      width: 100% !important;
    }
    
    #search-input, #tag-filter, #jump-search-input {
      width: 100% !important;
      padding: 8px !important;
      font-size: 18px !important;
    }
    
    .mobile-control-bar {
      display: flex; /* Show on mobile */
    }
    
    /* Adjust the modal size for mobile */
    .modal-content {
      width: 95%;
      padding: 15px;
    }
    
    /* Show edit form fields responsively */
    #edit-front, #edit-back, #edit-tags {
      font-size: 18px !important;
      padding: 8px !important;
    }
    
    /* Make buttons more touchable */
    button {
      min-height: 44px;
      min-width: 44px;
    }
    
    .embedded-card-image {
      width: 100%;
      object-fit: contain;
    }
    .flashcard {
      margin: 20px auto;
      padding: 20px;
      border: 2px solid #ccc;
      width: 60%;
      min-height: 300px;
      max-width: 600px !important;
      text-align: left;
      background: #fff;
      border-radius: 10px;
      cursor: pointer;
      box-shadow: 2px 2px 12px rgba(0,0,0,0.1);
      font-size: 20px;
      line-height: 1.5;
    }
    .flashcard li {
      margin-top: 5px;
      margin-bottom: 5px;
    }
    .flashcard textarea {
      width: 100%;
      resize: vertical;
      font-size: 18px;
    }
    .flashcard p, .flashcard div, .flashcard ol, .flashcard ul {
      margin-top: 5px;
      margin-bottom: 5px;
    }
    .flashcard .MJX-TEX {
      margin: 5px 0;
      display: inline-block;
    }
    .flashcard > * {
      margin-bottom: 8px;
    }
    #edit-tags { 
      font-family: sans-serif;
      font-size: 18px;
    }
    #card-info, #tags-info {
      margin-top: 10px;
      font-size: 18px;
      color: #555;
    }
    /* New Jump Search Row with same formatting as filter rows */
    #jump-search-controls {
      margin: 18px auto;
      width: 100%;
      max-width: 400px;
    }
    #jump-search-controls input {
      font-family: sans-serif;
      font-size: 18px;
    }
    #jump-search-controls .filter-input {
      width: 200px !important;
    }
    #jump-search-input {
      width: 200px !important;
    }
    /* The jump search row will reuse the filter table styling */
    .filter-table {
      display: table;
      margin: 10px auto;
      width: 100%;
      max-width: 400px;
    }
    .filter-row {
      display: table-row;
    }
    .filter-cell {
      display: table-cell;
      padding: 5px;
      vertical-align: middle;
      font-size: 18px;
      color: #555;
    }
    .filter-label {
      text-align: right;
      white-space: nowrap;
    }
    .filter-input {
      width: 80px !important;
    }
    .filter-value,
    .filter-operator {
      text-align: left;
      padding-left: 10px;
    }
    .filter-value {
      text-align: center;
      padding-left: 10px;
      width: 40px;
    }
    #filter-controls {
      margin: 18px auto;
      width: 100%;
      max-width: 400px;
    }
    #filter-controls input {
      font-family: sans-serif;
      font-size: 18px;
    }
    #card-controls {
      margin: 18px auto;
      width: 100%;
      max-width: 300px;
    }
    #filter-actions, #edit-actions, #card-info-and-actions {
      margin-bottom: 10px;
    }
    #edit-actions {
      margin-top: 10px;
    }
    #controls input, #controls button {
      font-size: 18px;
      padding: 5px 5px;
      margin: 0 5px;
    }
    .filter-buttons-wrapper {
      display: table-cell;
      width: 100%;
      text-align: center;
    }
    .filter-buttons-inner {
      display: inline-flex;
      gap: 10px;
      margin-bottom: 10px;
    }
    .filter-buttons-inner button {
      font-size: 18px;
      padding: 5px 5px;
      box-sizing: border-box;
    }
    .edit-buttons-inner {
      display: inline-flex;
      gap: 10px;
    }
    .edit-buttons-inner button {
      font-size: 18px;
      padding: 5px 5px;
      box-sizing: border-box;
    }
    .card-buttons-outter {
      display: flex;
      justify-content: center;
      align-items: center;
      width: 100%;
      margin-top: 20px;
    }
    .card-buttons-inner {
      display: inline-flex;
      gap: 10px;
    }
    .card-buttons-inner button {
      width: 90px;
      height: 30px;
    }
    .card-table {
      display: table;
      margin: 10px auto;
      width: 100%;
    }
    .card-row {
      display: table-row;
    }
    .card-cell {
      display: table-cell;
      padding: 5px;
      vertical-align: middle;
      font-size: 20px;
      color: #555;
    }
    .card-label {
      text-align: right;
      white-space: nowrap;
      font-size: 18px;
    }
    .card-input {
      width: 100px;
    }
    .card-value {
      text-align: center;
      padding-left: 10px;
      width: 40px;
    }
    #apply-filter {
      font-family: sans-serif;
      font-size: 18px;
    }
    #clear-filter {
      font-family: sans-serif;
      font-size: 18px;
    }
    #save-card-edits {
      font-size: 18px;
      padding: 5px 10px;
      height: 32px;
    }
    #grok-filter-operator {
      font-size: 18px;
    }
    textarea {
      font-family: sans-serif;
      font-size: 18px;
    }
    button {
      font-family: sans-serif;
      font-size: 18px;
    }
    #search-input {
      width: 200px !important;
      font-family: sans-serif;
      font-size: 18px;
    }
    #tag-filter {
      width: 200px !important;
      font-family: sans-serif;
      font-size: 18px;
    }
    mjx-container[jax="CHTML"] {
      display: inline !important;
      vertical-align: baseline !important;
      margin: 0 !important;
      padding: 0 !important;
      font-size: 1em !important;
    }
    #performance-stats {
      margin-top: 10px;
      font-size: 18px;
      color: #555;
    }
    .high-performance {
      color: #28a745 !important;
    }
    .medium-performance {
      color: #ffc107 !important;
    }
    .low-performance {
      color: #dc3545 !important;
    }
    .save-notification {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background-color: #4CAF50;
      color: white;
      padding: 10px 20px;
      border-radius: 4px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
      z-index: 1000;
      opacity: 0;
      transition: opacity 0.3s ease-in-out;
    }
    .save-notification.show {
      opacity: 1;
    }
    /* New styling for the incorrect answer modal */
    .modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.4);
    }
    .modal-content {
      background-color: #fefefe;
      margin: 15% auto;
      padding: 20px;
      border: 1px solid #888;
      width: 80%;
      max-width: 500px;
      border-radius: 5px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    }
    .modal-title {
      font-size: 1.2em;
      margin-bottom: 15px;
    }
    .modal-input {
      width: 100%;
      padding: 10px;
      margin-bottom: 15px;
      box-sizing: border-box;
      font-size: 18px;
      font-family: sans-serif;
    }
    .modal-buttons {
      text-align: right;
    }
    .modal-button {
      padding: 8px 16px;
      margin-left: 10px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 16px;
    }
    .modal-submit {
      background-color: #4CAF50;
      color: white;
    }
    .modal-cancel {
      background-color: #f1f1f1;
    }

    /* Add specific style for required checkbox */
    #required-info {
      margin-top: 10px;
      font-size: 18px;
      color: #555;
      display: flex;
      align-items: center;
    }
    
    #absolutely-required-checkbox {
      margin-right: 8px;
      cursor: pointer;
      width: 18px;
      height: 18px;
    }
    
    /* Make the checkbox label clickable */
    .required-label {
      cursor: pointer;
      user-select: none;
    }
    
    /* Style for the required filter dropdown */
    #required-filter {
      width: 100%;
      padding: 8px;
      font-size: 18px;
      font-family: sans-serif;
    }
  </style>
</head>
<body>
  <!-- Mobile control bar with action buttons -->
  <div class="mobile-control-bar">
    <button class="mobile-control-button" id="mobile-edit">
      <span class="material-icons">edit</span>
    </button>
    <button class="mobile-control-button" id="mobile-filter">
      <span class="material-icons">filter_list</span>
    </button>
    <button class="mobile-control-button" id="mobile-history">
      <span class="material-icons">history</span>
    </button>
    <button class="mobile-control-button" id="mobile-clear-attempts">
      <span class="material-icons">delete_sweep</span>
    </button>
  </div>

  <!-- Focus mode toggle button (visible on mobile) -->
  <button id="focus-mode-toggle">
    <span class="material-icons">center_focus_strong</span>
  </button>

  <!-- Menu button to show/hide mobile controls (visible on mobile) -->
  <button id="mobile-menu-toggle">
    <span class="material-icons">menu</span>
  </button>

  <div id="filter-controls">
    <div id="filter-actions">
      <div class="filter-table">
        <!-- Jump search -->
        <div class="filter-row">
          <div class="filter-cell filter-label">
            <label for="jump-search-input">Jump Search:</label>
          </div>
          <div class="filter-cell filter-input">
            <input type="text" id="jump-search-input" placeholder="(e.g., eigen value)">
          </div>
          <div class="filter-cell filter-value"></div>
          <div class="filter-cell filter-operator"></div>
        </div>
        <!-- Filter by content Row -->
        <div class="filter-row">
          <div class="filter-cell filter-label">
            <label for="search-input">Filter by content:</label>
          </div>
          <div class="filter-cell filter-input">
            <input type="text" id="search-input" placeholder="(e.g., decomposition)">
          </div>
          <div class="filter-cell filter-value"></div>
          <div class="filter-cell filter-operator"></div>
        </div>
        <!-- Tag Filter Row -->
        <div class="filter-row">
          <div class="filter-cell filter-label">
            <label for="tag-filter">Filter by Tag:</label>
          </div>
          <div class="filter-cell filter-input">
            <input type="text" id="tag-filter" placeholder="(e.g., 16.32)">
          </div>
          <div class="filter-cell filter-value"></div>
          <div class="filter-cell filter-operator"></div>
        </div>
        <!-- Absolutely Required Filter Row (NEW) -->
        <div class="filter-row">
          <div class="filter-cell filter-label">
            <label for="required-filter">Absolutely Required:</label>
          </div>
          <div class="filter-cell filter-input">
            <select id="required-filter">
              <option value="any">Any</option>
              <option value="true">Yes</option>
              <option value="false">No</option>
            </select>
          </div>
          <div class="filter-cell filter-value"></div>
          <div class="filter-cell filter-operator"></div>
        </div>
      </div>
      <div class="filter-buttons-inner">
        <button id="apply-filter" style="margin-right: 10px;">Apply Filter</button>
        <button id="clear-filter" style="margin-left: 10px;">Clear Filter</button>
      </div>
    </div>
    <div id="edit-actions">
      <div class="edit-buttons-inner">
        <button id="toggle-edit">Edit Card</button>
        <button id="add-card" style="display: none;">Add +</button>
        <button id="delete-card" style="display: none;">Delete -</button>
        <button id="clear-attempts" style="display: none;">Clear Attempts</button>
      </div>
    </div>
  </div>

  <div id="performance-stats"></div>
  <div class="flashcard" id="flashcard"></div>
  
  <div id="card-info"></div>
  <!-- Absolutely Required Checkbox (NEW) -->
  <div id="required-info">
    <input type="checkbox" id="absolutely-required-checkbox">
    <label for="absolutely-required-checkbox" class="required-label">Absolutely Required</label>
  </div>
  <div id="tags-info"></div>

  <!-- Mobile action buttons -->
  <div class="mobile-actions">
    <button class="mobile-button nav-button" id="mobile-prev">
      <span class="material-icons">arrow_back</span>
    </button>
    <button class="mobile-button incorrect-button" id="mobile-incorrect">
      <span class="material-icons">highlight_off</span>
    </button>
    <button class="mobile-button correct-button" id="mobile-correct">
      <span class="material-icons">check_circle</span>
    </button>
    <button class="mobile-button nav-button" id="mobile-next">
      <span class="material-icons">arrow_forward</span>
    </button>
  </div>
  
  <div id="card-controls">
    <div class="card-table">
    </div>
  </div>

  <!-- Incorrect attempts history section -->
  <div id="incorrect-attempts-history">
    <h3>Previous Mistakes</h3>
    <ul id="incorrect-attempts-list">
      <!-- Will be populated dynamically -->
    </ul>
  </div>

  <!-- Modal for incorrect answer feedback -->
  <div id="incorrect-modal" class="modal">
    <div class="modal-content">
      <div class="modal-title">What did you get wrong?</div>
      <input type="text" id="incorrect-reason" class="modal-input" placeholder="Describe what you got wrong (optional)">
      <div class="modal-buttons">
        <button class="modal-button modal-submit" id="incorrect-submit">Submit</button>
        <button class="modal-button modal-cancel" id="incorrect-cancel">Cancel</button>
      </div>
    </div>
  </div>

  <script>
    let allFlashcards = {{ flashcards | tojson }};
    let flashcards = allFlashcards.slice();
    let currentIndex = 0;
    let showingFront = true;
    let editMode = false;
    let focusMode = false;
    let mistakesHistoryVisible = true; // Track visibility of mistakes history

    // Variables for jump search
    let jumpSearchTerm = "";
    let jumpSearchResults = [];
    let jumpSearchCurrentIndex = 0;

    window.onload = function() {
      ensureCardProperties();
      loadStateFromLocalStorage();
      renderCard();
      setupIncorrectModal();
      updateMistakesHistoryVisibility(); // Apply history visibility
      initMobileHandlers(); // Initialize mobile touch and UI handlers
      
      // Set up event listener for the absolutelyRequired checkbox (NEW)
      document.getElementById("absolutely-required-checkbox").addEventListener("change", function() {
        if (flashcards.length === 0) return;
        const card = flashcards[currentIndex];
        card.absolutelyRequired = this.checked;
        persistFlashcards();
        showSaveNotification();
      });
    };
    
    // Ensure all cards have the required properties (NEW)
    function ensureCardProperties() {
      ensureAttemptsExist();
      
      // Make sure all cards have the absolutelyRequired property
      allFlashcards.forEach(card => {
        if (card.absolutelyRequired === undefined) {
          card.absolutelyRequired = false;
        }
      });
    }
    
    // Function to toggle mistakes history visibility
    function toggleMistakesHistoryVisibility() {
      mistakesHistoryVisible = !mistakesHistoryVisible;
      updateMistakesHistoryVisibility();
      saveStateToLocalStorage();
    }
    
    // Function to update visibility based on state
    function updateMistakesHistoryVisibility() {
      const historyDiv = document.getElementById("incorrect-attempts-history");
      historyDiv.style.display = mistakesHistoryVisible ? "block" : "none";
    }

    function setupIncorrectModal() {
      const modal = document.getElementById("incorrect-modal");
      const submitBtn = document.getElementById("incorrect-submit");
      const cancelBtn = document.getElementById("incorrect-cancel");
      const input = document.getElementById("incorrect-reason");

      submitBtn.addEventListener("click", function() {
        const reason = input.value.trim();
        recordAttempt(false, reason);
        closeIncorrectModal();
      });

      cancelBtn.addEventListener("click", function() {
        closeIncorrectModal();
        recordAttempt(false);
      });

      // Allow pressing Enter to submit
      input.addEventListener("keydown", function(e) {
        if (e.key === "Enter") {
          e.preventDefault();
          submitBtn.click();
        }
      });

      // Close modal if clicking outside
      window.addEventListener("click", function(e) {
        if (e.target === modal) {
          closeIncorrectModal();
          recordAttempt(false);
        }
      });
    }

    function showIncorrectModal() {
      const modal = document.getElementById("incorrect-modal");
      const input = document.getElementById("incorrect-reason");
      input.value = "";
      modal.style.display = "block";
      setTimeout(() => input.focus(), 100);
    }

    function closeIncorrectModal() {
      const modal = document.getElementById("incorrect-modal");
      modal.style.display = "none";
    }

    function saveStateToLocalStorage() {
      const state = {
        tagFilter: document.getElementById("tag-filter").value,
        searchInput: document.getElementById("search-input").value,
        requiredFilter: document.getElementById("required-filter").value, // NEW
        focusMode: focusMode,
        currentIndex: currentIndex,
        mistakesHistoryVisible: mistakesHistoryVisible
      };
      localStorage.setItem('flashcardState', JSON.stringify(state));
    }

    function loadStateFromLocalStorage() {
      const stateJson = localStorage.getItem('flashcardState');
      if (!stateJson) return;
      
      try {
        const state = JSON.parse(stateJson);
        document.getElementById("tag-filter").value = state.tagFilter || '';
        document.getElementById("search-input").value = state.searchInput || '';
        
        // Set the required filter dropdown value (NEW)
        if (state.requiredFilter) {
          document.getElementById("required-filter").value = state.requiredFilter;
        }
        
        applyCurrentFilter();
        if (state.currentIndex !== undefined && flashcards.length > 0) {
          currentIndex = Math.min(state.currentIndex, flashcards.length - 1);
          if (currentIndex < 0) currentIndex = 0;
        }
        if (state.focusMode) {
          focusMode = false;
          toggleFocusMode();
        }
        if (state.mistakesHistoryVisible !== undefined) {
          mistakesHistoryVisible = state.mistakesHistoryVisible;
          updateMistakesHistoryVisibility();
        }
        renderCard();
      } catch (error) {
        console.error("Error loading state from localStorage:", error);
      }
    }

    function toggleFocusMode() {
      // Add this line to get a reference to the menu button
      const menuButton = document.getElementById("mobile-menu-toggle");

      focusMode = !focusMode;

      // Elements to hide in focus mode
      const nonEssentialElements = [
        document.getElementById("filter-actions"),
        document.getElementById("tags-info"),
        document.getElementById("edit-actions"),
        // document.getElementById("required-info") // Also hide the required info in focus mode (NEW)
      ];
      
      // Mobile-specific elements to toggle in focus mode
      const mobileControlBar = document.querySelector(".mobile-control-bar");
      const filterControls = document.getElementById("filter-controls");
      
      if (focusMode) {
        // Add this line to hide the menu button in focus mode
        if (menuButton) menuButton.style.display = "none";

        // Hide non-essential elements
        nonEssentialElements.forEach(el => {
          if (el) el.style.display = "none";
        });
        
        // Hide filter controls container in focus mode
        if (filterControls) filterControls.style.display = "none";
        
        // Hide edit button if not in edit mode
        if (!editMode) {
          document.getElementById("toggle-edit").style.display = "none";
        }
        
        // Hide mobile control bar in focus mode
        if (mobileControlBar) mobileControlBar.style.display = "none";
        
        // Keep mobile action buttons visible even in focus mode
        // They're essential for card interaction on mobile
      } else {
        // Add this line to show the menu button when exiting focus mode
        if (menuButton) menuButton.style.display = "flex";

        // For desktop view, show non-essential elements
        if (window.innerWidth > 768) {
          nonEssentialElements.forEach(el => {
            if (el) el.style.display = "block";
          });
          
          // Show filter controls container
          if (filterControls) filterControls.style.display = "block";
          
          if (!editMode) {
            document.getElementById("toggle-edit").style.display = "block";
          }
        } else {
          // For mobile view, keep filter controls hidden until explicitly shown
          // but make sure they're ready to be shown
          if (filterControls) filterControls.style.display = "none";
          document.getElementById("filter-actions").style.display = "block";
        }
        
          // MODIFY this line to ensure mobile control bar is hidden when exiting focus mode
          if (mobileControlBar) mobileControlBar.style.display = "none";
      }
      
      // Update button appearance
      const focusButton = document.getElementById("focus-mode-toggle");
      if (focusMode) {
        focusButton.style.backgroundColor = "#28a745"; // Green when active
      } else {
        focusButton.style.backgroundColor = "#4682B4"; // Default blue when inactive
      }
      
      saveStateToLocalStorage();
    }

    function persistFlashcards() {
      fetch("/save", {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify(allFlashcards)
      })
      .then(response => response.json())
      .then(data => {
        if (!data.success) {
          alert("Failed to save changes.");
        }
      })
      .catch(error => {
        console.error("Persist error:", error);
        alert("Error saving changes.");
      });
    }

    function clearCardAttempts() {
      if (flashcards.length === 0) return;
      const card = flashcards[currentIndex];
      card.attempts = [];
      persistFlashcards();
      renderCard();
    }
    
    document.getElementById("clear-attempts").addEventListener("click", function() {
      if (confirm("Are you sure you want to clear all attempt history for this card?")) {
        clearCardAttempts();
      }
    });

    document.getElementById("tag-filter").addEventListener("keydown", function(e) {
      if (e.key === "Enter") {
        e.preventDefault();
        document.getElementById("apply-filter").click();
        document.activeElement.blur();
      }
    });

    document.getElementById("search-input").addEventListener("keydown", function(e) {
      if (e.key === "Enter") {
        e.preventDefault();
        document.getElementById("apply-filter").click();
        document.activeElement.blur();
      }
    });

    // Jump search functionality:
    document.getElementById("jump-search-input").addEventListener("keydown", function(e) {
      if (e.key === "Enter") {
        e.preventDefault();
        let term = this.value.trim().toLowerCase();
        if (term === "") return;
        // If the term is different from the last jump search, recalc the results.
        if (term !== jumpSearchTerm) {
          jumpSearchTerm = term;
          jumpSearchResults = [];
          jumpSearchCurrentIndex = 0;
          flashcards.forEach((card, index) => {
            if (
              card.front.toLowerCase().includes(term) ||
              card.back.toLowerCase().includes(term)
            ) {
              jumpSearchResults.push(index);
            }
          });
          if (jumpSearchResults.length === 0) {
            alert("No card with that content is found.");
            return;
          }
        }
        // Jump to the next matching card.
        if (jumpSearchResults.length > 0) {
          currentIndex = jumpSearchResults[jumpSearchCurrentIndex];
          jumpSearchCurrentIndex = (jumpSearchCurrentIndex + 1) % jumpSearchResults.length;
          renderCard();
        } else {
          alert("No card with that content is found.");
        }
      }
    });

    function applyCurrentFilter() {
      let filteredCards = allFlashcards.slice();
      const tagInput = document.getElementById("tag-filter").value.trim().toLowerCase();
      if (tagInput !== "") {
        const filterTags = tagInput.split(",").map(tag => tag.trim()).filter(tag => tag !== "");
        filteredCards = filteredCards.filter(card => {
          const cardTags = card.tags.map(tag => tag.toLowerCase());
          return filterTags.every(filterTag => cardTags.includes(filterTag));
        });
      }
      const searchText = document.getElementById("search-input").value.trim().toLowerCase();
      if (searchText !== "") {
        filteredCards = filteredCards.filter(card =>
          card.front.toLowerCase().includes(searchText) ||
          card.back.toLowerCase().includes(searchText)
        );
      }
      
      // Apply the absolutely required filter (NEW)
      const requiredFilter = document.getElementById("required-filter").value;
      if (requiredFilter !== "any") {
        const isRequired = requiredFilter === "true";
        filteredCards = filteredCards.filter(card => 
          card.absolutelyRequired === isRequired
        );
      }
      
      flashcards = filteredCards;
      saveStateToLocalStorage();
      return flashcards;
    }

    function setupDragDrop(textareaId) {
      const textarea = document.getElementById(textareaId);
      if (!textarea) return;
      textarea.addEventListener("dragover", function(e) {
        e.preventDefault();
      });
      textarea.addEventListener("drop", function(e) {
        e.preventDefault();
        const files = e.dataTransfer.files;
        if (files.length > 0) {
          const file = files[0];
          if (!file.type.startsWith("image/")) {
            alert("Only image files are allowed.");
            return;
          }
          const formData = new FormData();
          formData.append("image", file);
          fetch("/upload", {
            method: "POST",
            body: formData
          })
          .then(response => response.json())
          .then(data => {
            if (data.url) {
              textarea.value += `<div style="width: 100%; height: 100%;"><img class="embedded-card-image" src="${data.url}"></div>`;
            } else {
              alert("Image upload failed.");
            }
          })
          .catch(error => {
            console.error("Upload error:", error);
            alert("Image upload error.");
          });
        }
      });
    }

    function ensureAttemptsExist() {
      allFlashcards.forEach(card => {
        if (!card.attempts) {
          card.attempts = [];
        }
      });
    }

    function getPerformanceStats(card) {
      if (!card.attempts || card.attempts.length === 0) {
        return { percentage: 0, total: 0 };
      }
      const totalAttempts = card.attempts.length;
      const correctAttempts = card.attempts.filter(attempt => attempt.correct).length;
      const percentage = (correctAttempts / totalAttempts) * 100;
      return {
        percentage: percentage.toFixed(2),
        total: totalAttempts
      };
    }

    function recordAttempt(correct, reason = null) {
      if (flashcards.length === 0) return;
      const card = flashcards[currentIndex];
      if (!card.attempts) {
        card.attempts = [];
      }
      
      const attemptData = {
        timestamp: Date.now(),
        correct: correct
      };
      
      // Only add reason if it's provided and not empty
      if (reason) {
        attemptData.reason = reason;
      }
      
      card.attempts.push(attemptData);
      persistFlashcards();
      renderCard();
    }

    function applyPerformanceColor(percentage, totalAttempts) {
      const performanceStats = document.getElementById("performance-stats");
      performanceStats.classList.remove("high-performance", "medium-performance", "low-performance");
      
      // Only apply colors if there are attempts
      if (totalAttempts > 0) {
        if (percentage >= 80) {
          performanceStats.classList.add("high-performance");
        } else if (percentage >= 50) {
          performanceStats.classList.add("medium-performance");
        } else {
          // This will now apply to 0% with attempts as well
          performanceStats.classList.add("low-performance");
        }
      }
    }

    function autoResizeTextarea(textarea) {
      textarea.style.height = 'auto';
      textarea.style.height = textarea.scrollHeight + 'px';
    }

    function renderIncorrectAttempts() {
      const attemptsList = document.getElementById("incorrect-attempts-list");
      attemptsList.innerHTML = "";
      
      if (flashcards.length === 0) {
        attemptsList.innerHTML = "<p class='no-attempts-message'>No cards matched the filter.</p>";
        return;
      }
      
      const card = flashcards[currentIndex];
      
      if (!card.attempts || card.attempts.length === 0) {
        attemptsList.innerHTML = "<p class='no-attempts-message'>No recorded mistakes for this card.</p>";
        return;
      }
      
      // Filter for incorrect attempts that have a reason
      const incorrectAttempts = card.attempts
        .filter(attempt => !attempt.correct && attempt.reason)
        .sort((a, b) => b.timestamp - a.timestamp); // Sort by timestamp, newest first
      
      if (incorrectAttempts.length === 0) {
        attemptsList.innerHTML = "<p class='no-attempts-message'>No detailed mistake records for this card.</p>";
        return;
      }
      
      incorrectAttempts.forEach((attempt) => {
        const attemptDate = new Date(attempt.timestamp);
        const dateString = attemptDate.toLocaleString(); // Format date/time
        
        const listItem = document.createElement("li");
        listItem.className = "incorrect-attempt-item";
        
        // Create delete button
        const deleteButton = document.createElement("button");
        deleteButton.className = "delete-attempt-button";
        deleteButton.setAttribute("title", "Delete this mistake record");
        deleteButton.setAttribute("data-timestamp", attempt.timestamp); // Store timestamp for identification
        
        // Add Material Icons icon
        const iconSpan = document.createElement("span");
        iconSpan.className = "material-icons";
        iconSpan.textContent = "delete"; // Using the "delete" icon
        deleteButton.appendChild(iconSpan);
        
        deleteButton.addEventListener("click", function(e) {
          e.stopPropagation(); // Prevent event bubbling
          deleteIncorrectAttempt(attempt.timestamp);
        });
        
        const dateElement = document.createElement("div");
        dateElement.className = "incorrect-attempt-date";
        dateElement.textContent = dateString;
        
        const reasonElement = document.createElement("div");
        reasonElement.className = "incorrect-attempt-reason";
        reasonElement.textContent = attempt.reason;
        
        listItem.appendChild(deleteButton);
        listItem.appendChild(dateElement);
        listItem.appendChild(reasonElement);
        attemptsList.appendChild(listItem);
      });
    }
    
    // Function to delete an incorrect attempt
    function deleteIncorrectAttempt(timestamp) {
      if (flashcards.length === 0) return;
      
      const card = flashcards[currentIndex];
      if (!card.attempts) return;
      
      // Find the attempt with the matching timestamp
      const attemptIndex = card.attempts.findIndex(attempt => attempt.timestamp === parseInt(timestamp, 10));
      
      if (attemptIndex !== -1) {
        // Remove the attempt
        card.attempts.splice(attemptIndex, 1);
        
        // Persist the change
        persistFlashcards();
        
        // Re-render the list
        renderIncorrectAttempts();
      }
    }
    
    function renderCard() {
      if (flashcards.length === 0) {
        document.getElementById("flashcard").innerText = "No cards match the filter.";
        document.getElementById("card-info").innerText = "";
        document.getElementById("performance-stats").innerText = "";
        document.getElementById("incorrect-attempts-list").innerHTML = "<p class='no-attempts-message'>No cards matched the filter.</p>";
        // Hide the absolutely required checkbox when no cards match (NEW)
        document.getElementById("required-info").style.display = "none";
        return;
      }
      
      // Show the absolutely required checkbox (NEW)
      // document.getElementById("required-info").style.display = focusMode ? "none" : "block";
      document.getElementById("required-info").style.display = "block";
      
      if (currentIndex < 0 || currentIndex >= flashcards.length) {
        currentIndex = 0;
      }
      const card = flashcards[currentIndex];
      
      // Update the absolutely required checkbox (NEW)
      document.getElementById("absolutely-required-checkbox").checked = card.absolutelyRequired || false;
      
      if (editMode) {
        document.getElementById("flashcard").innerHTML = `
          <div style="margin-bottom: 10px;"><label style="font-size: 24px;">Front</label></div>
          <textarea id="edit-front" rows="5" style="width:100%; resize: vertical; overflow: hidden;">${card.front}</textarea><br>
          <div style="margin: 10px 0px;"><label style="font-size: 24px;">Back</label></div>
          <textarea id="edit-back" rows="5" style="width:100%; resize: vertical; overflow: hidden;">${card.back}</textarea><br>
          <div style="margin: 10px 0px;"><label style="font-size: 24px;">Tags</label></div>
          <input type="text" id="edit-tags" style="width:100%;" value="${card.tags.join(', ')}"><br>
          <div class="card-buttons-outter">
            <div class="card-buttons-inner">
              <button id="save-card-edits">Save</button>
            </div>
          </div>
        `;
        setupDragDrop("edit-front");
        setupDragDrop("edit-back");
        const frontTextarea = document.getElementById("edit-front");
        const backTextarea = document.getElementById("edit-back");
        frontTextarea.addEventListener("input", function() {
          autoResizeTextarea(frontTextarea);
        });
        backTextarea.addEventListener("input", function() {
          autoResizeTextarea(backTextarea);
        });
        autoResizeTextarea(frontTextarea);
        autoResizeTextarea(backTextarea);
        document.getElementById("save-card-edits").addEventListener("click", function(e) {
          e.stopPropagation();
          flashcards[currentIndex].front = document.getElementById("edit-front").value;
          flashcards[currentIndex].back = document.getElementById("edit-back").value;
          flashcards[currentIndex].tags = document.getElementById("edit-tags").value.split(',')
            .map(tag => tag.trim())
            .filter(tag => tag.length > 0);
          persistFlashcards();
          showSaveNotification();
          renderCard();
        });
      } else {
        document.getElementById("flashcard").innerHTML = showingFront ? card.front : card.back;
      }
      
      // Render the incorrect attempts history
      renderIncorrectAttempts();
      
      document.getElementById("card-info").innerText = `Card ${currentIndex + 1} of ${flashcards.length}`;
      const stats = getPerformanceStats(card);
      document.getElementById("performance-stats").innerText = `${stats.percentage}% correct (${stats.total} attempts)`;
      applyPerformanceColor(parseFloat(stats.percentage), stats.total);
      if (!focusMode) {
        document.getElementById("tags-info").innerText = `Tags: ${card.tags.join(", ")}`;
      }
      if (window.MathJax) {
        if (typeof MathJax.typesetPromise === "function") {
          MathJax.typesetPromise();
        } else if (typeof MathJax.typeset === "function") {
          MathJax.typeset();
        }
      }
      saveStateToLocalStorage();
    }

    // Mobile touch and UI handlers
    function initMobileHandlers() {
      // Touch variables for swipe detection
      let touchStartX = 0;
      let touchEndX = 0;
      let touchStartY = 0;
      let touchEndY = 0;
      
      // Minimum distance for a swipe
      const minSwipeDistance = 50;
      
      // Add touch event handlers to the flashcard
      const flashcard = document.getElementById("flashcard");
      
      // Track if it's a tap or a swipe
      let isTap = false;
      let touchStartTime = 0;
      
      flashcard.addEventListener('touchstart', e => {
        touchStartX = e.changedTouches[0].screenX;
        touchStartY = e.changedTouches[0].screenY;
        touchStartTime = new Date().getTime();
        isTap = true;
      });
      
      flashcard.addEventListener('touchmove', e => {
        // If moved more than a small threshold, it's not a tap
        const moveX = Math.abs(e.changedTouches[0].screenX - touchStartX);
        const moveY = Math.abs(e.changedTouches[0].screenY - touchStartY);
        if (moveX > 10 || moveY > 10) {
          isTap = false;
        }
      });
      
      flashcard.addEventListener('touchend', e => {
        touchEndX = e.changedTouches[0].screenX;
        touchEndY = e.changedTouches[0].screenY;
        const touchEndTime = new Date().getTime();
        
        // Calculate horizontal distance
        const deltaX = touchEndX - touchStartX;
        const deltaY = touchEndY - touchStartY;
        
        // Check if it's a tap (short duration, minimal movement)
        if (isTap && touchEndTime - touchStartTime < 300) {
          // It's a tap - flip the card
          if (!editMode) {
            showingFront = !showingFront;
            renderCard();
          }
          return;
        }
        
        // Check if horizontal swipe is more significant than vertical
        if (Math.abs(deltaX) > Math.abs(deltaY)) {
          // Check if it's a left or right swipe (with minimum distance)
          if (Math.abs(deltaX) > minSwipeDistance) {
            if (deltaX > 0) {
              // Right swipe - previous card
              if (currentIndex > 0) {
                currentIndex--;
                showingFront = true;
                renderCard();
                saveStateToLocalStorage();
              }
            } else {
              // Left swipe - next card
              if (currentIndex < flashcards.length - 1) {
                currentIndex++;
                showingFront = true;
                renderCard();
                saveStateToLocalStorage();
              }
            }
          }
        }
      });
      
      // Mobile action buttons
      document.getElementById("mobile-prev").addEventListener("click", function() {
        if (!editMode && currentIndex > 0) {
          currentIndex--;
          showingFront = true;
          renderCard();
          saveStateToLocalStorage();
        }
      });
      
      document.getElementById("mobile-next").addEventListener("click", function() {
        if (!editMode && currentIndex < flashcards.length - 1) {
          currentIndex++;
          showingFront = true;
          renderCard();
          saveStateToLocalStorage();
        }
      });
      
      document.getElementById("mobile-correct").addEventListener("click", function() {
        if (!editMode && flashcards.length > 0) {
          recordAttempt(true);
        }
      });
      
      document.getElementById("mobile-incorrect").addEventListener("click", function() {
        if (!editMode && flashcards.length > 0) {
          showIncorrectModal();
        }
      });
      
      // Control buttons
      document.getElementById("mobile-edit").addEventListener("click", function() {
        // Toggle edit mode directly instead of relying on the desktop button
        editMode = !editMode;
        if (!editMode) {
          showingFront = true;
        }
        
        // Update UI to reflect edit mode change
        document.getElementById("toggle-edit").innerText = editMode ? "Exit Edit" : "Edit Card";
        document.getElementById("add-card").style.display = editMode ? "inline-block" : "none";
        document.getElementById("delete-card").style.display = editMode ? "inline-block" : "none";
        document.getElementById("clear-attempts").style.display = editMode ? "inline-block" : "none";
        renderCard();
      });
      
      document.getElementById("mobile-filter").addEventListener("click", function() {
        const filterControls = document.getElementById("filter-controls");
        const filterActions = document.getElementById("filter-actions");
        
        // Toggle visibility of the filter controls
        if (filterControls.style.display === "none") {
          filterControls.style.display = "block";
          filterActions.style.display = "block"; // Make sure the inner content is also visible
        } else {
          filterControls.style.display = "none";
        }
      });
      
      document.getElementById("mobile-history").addEventListener("click", function() {
        toggleMistakesHistoryVisibility();
      });
      
      document.getElementById("mobile-clear-attempts").addEventListener("click", function() {
        if (flashcards.length === 0) return;
        
        if (confirm("Are you sure you want to clear all attempt history for this card?")) {
          clearCardAttempts();
        }
      });
      
      // Focus mode toggle button
      document.getElementById("focus-mode-toggle").addEventListener("click", function() {
        toggleFocusMode();
      });

      // Menu toggle button
      document.getElementById("mobile-menu-toggle").addEventListener("click", function() {
        const mobileControlBar = document.querySelector(".mobile-control-bar");
        if (mobileControlBar.style.display === "flex") {
          mobileControlBar.style.display = "none";
        } else {
          mobileControlBar.style.display = "flex";
        }
      });
      
      // Adjust UI for mobile
      setupMobileUI();
    }
    
    function setupMobileUI() {
      // Initially hide the mobile control bar
      const mobileControlBar = document.querySelector(".mobile-control-bar");
      if (mobileControlBar) {
        mobileControlBar.style.display = "none";
      }

      // Show/hide menu button based on focus mode
      const menuButton = document.getElementById("mobile-menu-toggle");
      if (menuButton) {
        menuButton.style.display = focusMode ? "none" : "flex";
      }

      // Check if we're on a mobile device
      if (window.innerWidth <= 768) {
        // Initially hide filter controls until explicitly shown by the user
        const filterControls = document.getElementById("filter-controls");
        // Only set display none if it's not already set by focus mode
        if (!focusMode) {
          filterControls.style.display = "none";
        }
      }
    }
    
    // Add window resize event to adjust UI for orientation changes
    window.addEventListener('resize', function() {
      setupMobileUI();
    });

    document.getElementById("toggle-edit").addEventListener("click", function() {
      editMode = !editMode;
      if (!editMode) {
        showingFront = true;
        if (focusMode) {
          document.getElementById("toggle-edit").style.display = "none";
        }
      } else {
        document.getElementById("toggle-edit").style.display = "inline-block";
      }
      document.getElementById("toggle-edit").innerText = editMode ? "Exit Edit" : "Edit Card";
      document.getElementById("add-card").style.display = editMode ? "inline-block" : "none";
      document.getElementById("delete-card").style.display = editMode ? "inline-block" : "none";
      document.getElementById("clear-attempts").style.display = editMode ? "inline-block" : "none";
      renderCard();
    });

    document.getElementById("add-card").addEventListener("click", function() {
      const tagInput = document.getElementById("tag-filter").value.trim();
      const defaultTags = tagInput ? tagInput.split(",").map(tag => tag.trim()).filter(tag => tag !== "") : [];
      const newCard = {
        "id": Date.now(),
        "front": "TODO: New front content",
        "back": "TODO: New back content",
        "tags": defaultTags,
        "understanding": 1,
        "absolutelyRequired": false // Initialize with false (NEW)
      };
      if (flashcards.length > 0) {
        const currentCardId = flashcards[currentIndex].id;
        const masterIndex = allFlashcards.findIndex(card => card.id === currentCardId);
        allFlashcards.splice(masterIndex + 1, 0, newCard);
      } else {
        allFlashcards.push(newCard);
      }
      applyCurrentFilter();
      currentIndex = flashcards.findIndex(card => card.id === newCard.id);
      if (currentIndex < 0) {
        currentIndex = 0;
      }
      persistFlashcards();
      renderCard();
      saveStateToLocalStorage();
    });

    document.getElementById("delete-card").addEventListener("click", function() {
      if (flashcards.length === 0) return;
      const cardId = flashcards[currentIndex].id;
      allFlashcards = allFlashcards.filter(card => card.id !== cardId);
      savedCurrentIdx = currentIndex;
      applyCurrentFilter();
      currentIndex = savedCurrentIdx;
      if (currentIndex >= flashcards.length) {
        currentIndex = flashcards.length - 1;
      }
      persistFlashcards();
      renderCard();
      saveStateToLocalStorage();
    });

    document.addEventListener('keydown', function(e) {
      if (e.key === "Escape") {
        if (document.activeElement && document.activeElement !== document.body) {
          document.activeElement.blur();
          e.preventDefault();
          return;
        }
      }
      if (['INPUT', 'TEXTAREA'].includes(document.activeElement.tagName)) {
        return;
      }
      if (e.key === "f") {
        toggleFocusMode();
        return;
      }
      if (e.key === "h") {
        toggleMistakesHistoryVisibility();
        return;
      }
      if (focusMode && !editMode) {
        if (e.key === "c") {
          recordAttempt(true);
          return;
        } else if (e.key === "x") {
          // Show the incorrect answer modal instead of immediately marking incorrect
          showIncorrectModal();
          return;
        }
      }
      if (e.key === "e") {
        editMode = !editMode;
        document.getElementById("toggle-edit").innerText = editMode ? "Exit Edit" : "Edit Card";
        document.getElementById("add-card").style.display = editMode ? "inline-block" : "none";
        document.getElementById("delete-card").style.display = editMode ? "inline-block" : "none";
        renderCard();
        return;
      }
      if (e.key === "r" && e.ctrlKey && !e.metaKey) {
        if (flashcards.length === 0) return;
        if (confirm("Are you sure you want to clear all attempt history for this card?")) {
          clearCardAttempts();
        }
        return;
      }
      if (["1", "2", "3"].includes(e.key)) {
        const newValue = parseInt(e.key, 10);
        if (flashcards.length === 0) return;
        persistFlashcards();
        renderCard();
        saveStateToLocalStorage();
        return;
      }
      if (e.key === "a" && editMode) {
        const addButton = document.getElementById("add-card");
        if (addButton) {
          addButton.click();
        }
        return;
      }
      // if (e.key === "d" && editMode) {
      //   const deleteButton = document.getElementById("delete-card");
      //   if (deleteButton) {
      //     deleteButton.click();
      //   }
      //   return;
      // }
      if (e.key === "s" && editMode) {
        const saveButton = document.getElementById("save-card-edits");
        if (saveButton) {
          saveButton.click();
        }
        return;
      }
      if (e.key === "r") {
        const absolutelyRequiredCheckbox = document.getElementById("absolutely-required-checkbox");
        if (absolutelyRequiredCheckbox) {
          absolutelyRequiredCheckbox.click();
        }
        return;
      }
      if (flashcards.length === 0) return;
      if (e.key === "ArrowRight") {
        if (currentIndex < flashcards.length - 1) {
          currentIndex++;
          showingFront = true;
          renderCard();
          saveStateToLocalStorage();
        }
      } else if (e.key === "ArrowLeft") {
        if (currentIndex > 0) {
          currentIndex--;
          showingFront = true;
          renderCard();
          saveStateToLocalStorage();
        }
      } else if (e.key === " " || e.key === "ArrowUp" || e.key === "ArrowDown") {
        if (!editMode) {
          e.preventDefault();
          showingFront = !showingFront;
          renderCard();
        }
      }
    });

    document.getElementById("apply-filter").addEventListener("click", function() {
      applyCurrentFilter();
      renderCard();
      saveStateToLocalStorage();
    });

    document.getElementById("clear-filter").addEventListener("click", function() {
      document.getElementById("tag-filter").value = "";
      document.getElementById("search-input").value = "";
      document.getElementById("required-filter").value = "any"; // Reset required filter (NEW)
      flashcards = allFlashcards.slice();
      renderCard();
      saveStateToLocalStorage();
    });

    document.getElementById("tag-filter").addEventListener("change", function() {
      saveStateToLocalStorage();
    });
    
    document.getElementById("search-input").addEventListener("change", function() {
      saveStateToLocalStorage();
    });
    
    // Add change event for required filter (NEW)
    document.getElementById("required-filter").addEventListener("change", function() {
      saveStateToLocalStorage();
    });

    const saveNotification = document.createElement('div');
    saveNotification.className = 'save-notification';
    saveNotification.textContent = 'Changes saved successfully!';
    saveNotification.style.display = 'none';
    document.body.appendChild(saveNotification);

    function showSaveNotification() {
      saveNotification.style.display = 'block';
      saveNotification.classList.add('show');
      setTimeout(() => {
        saveNotification.classList.remove('show');
        setTimeout(() => {
          saveNotification.style.display = 'none';
        }, 300);
      }, 2000);
    }
  </script>
</body>
</html>